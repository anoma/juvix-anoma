module Anoma.Logic;

import Stdlib.Prelude open;
import Anoma.Transaction as Transaction open using {Transaction; module Transaction; DeltaComponent; module DeltaComponent; Resource; module Resource};
import Data.Map as Map;

module AuxMutual;
  mkLogicFunction
    (f : Transaction -> Bool)
    : Transaction -> Bool := f ∘ mkTransaction;

  mkDeltaComponent
    : DeltaComponent -> Transaction.Kind × Int
    | (DeltaComponent.mk denom sign amount) :=
      let
        k := Transaction.Kind.Private.mk denom;
        quantity := if sign (ofNat amount) (negNat amount);
      in k, quantity;

  terminating
  mkResource : Resource -> Transaction.Resource
    | (Resource.mk logic label quantity data eph nonce npk rseed) :=
      Transaction.Resource.mk
        (λ { r t := logic (mkInternalResource r) t })
        label
        quantity
        data
        eph
        nonce
        npk
        rseed;

  terminating
  mkTransaction : Transaction -> Transaction
    | (Transaction.mk roots commitments nullifiers proofs delta extra preference) :=
      Transaction.mk
        roots
        commitments
        nullifiers
        (map mkResource proofs)
        delta
        extra
        preference;

  terminating
  mkInternalDeltaComponent
    : Transaction.Kind × Int -> DeltaComponent
    | (kind, quantity) :=
      DeltaComponent.mk@{
        denom := Transaction.Kind.Private.Kind.id kind;
        sign := quantity >= 0;
        amount := abs quantity
      };

  terminating
  mkInternalResource
    : Transaction.Resource -> Resource
    | (Transaction.Resource.mk logic label quantity data eph nonce npk rseed) :=
      Resource.mk
        (λ { r t := logic (mkResource r) (mkTransaction t) })
        label
        quantity
        data
        eph
        nonce
        npk
        rseed;
end;

open AuxMutual using {mkLogicFunction} public;
